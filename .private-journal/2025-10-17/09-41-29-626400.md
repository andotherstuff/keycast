---
title: "9:41:29 AM - October 17, 2025"
date: 2025-10-16T20:41:29.626Z
timestamp: 1760647289626
---

## Project Notes

Keycast Database Architecture Research - Key Findings

CURRENT STATE:
- Multi-tenant Nostr key custody system (OAuth + NIP-46 remote signer)
- Using SQLite with Litestream replication on Cloud Run
- Application-level encryption: GCP KMS encrypts private keys BEFORE database storage
- Database stores encrypted blobs, not plaintext keys
- Multi-tenancy via tenant_id column (migration 0010_multi_tenancy.sql)
- Current queries use SQLite syntax (? placeholders) across ~80 occurrences in 13 files
- WAL mode enabled with busy_timeout=5000ms, synchronous=NORMAL
- Max 5 connections in pool, acquire_timeout=10s

CURRENT SCALE: Early stage, likely <10 tenants, <100 users currently

KEY RESEARCH FINDINGS:

1. DEFENSE IN DEPTH - ENCRYPTION LAYERING:
- Application KMS encryption + database encryption IS valuable defense in depth
- But: If SQLite file is on Cloud Run ephemeral storage, database-level encryption adds minimal value
- Threat model: DB encryption protects against disk/backup theft scenarios
- With Litestream backing up to GCS, the real attack surface is GCS bucket compromise
- RECOMMENDATION: Application KMS encryption is sufficient for keycast's threat model

2. POSTGRESQL RLS FOR MULTI-TENANCY:
- RLS provides runtime (NOT compile-time) tenant isolation
- Performance: RLS adds query planning overhead, BUT tenant_id filtering is simple predicate (minimal impact)
- Real benefit: Defense in depth - prevents developer bugs (forgetting WHERE tenant_id = X)
- With sqlx: Must use admin connection for compile-time checks, runtime connection with RLS policies
- LIMITATION: sqlx compile-time checks work with RLS, but no compile-time enforcement of tenant isolation

3. DATABASE-PER-TENANT ARCHITECTURE:
- Advantages: Complete isolation, simpler to reason about security, easier tenant deletion/backup
- Disadvantages: Connection pooling complexity (N*M pools for N users, M databases in PgBouncer)
- Cost: ONE PostgreSQL instance can host 50+ separate databases (schema overhead ~few MB each)
- Management: Tools like PgBouncer can handle multiple databases, but config complexity increases
- With Litestream: Can replicate multiple .db files (not tested at scale, but technically supported)

4. SQLITE WRITE BOTTLENECK REALITY:
- Single writer limit: ~3,600 writes/sec in WAL mode (vs 291/sec in rollback mode)
- Production example: Rails app sustained 2.5k+ write requests/sec with SQLite
- SQLITE_BUSY errors occur under concurrent write contention
- Your workload: OAuth flows (3-5 writes per auth), signing activity logging (1 write per signature)
- ESTIMATION: 5 tenants × 20 users × 10 ops/day = ~1,000 writes/day = 0.01 writes/sec
- VERDICT: SQLite write bottleneck NOT a concern at your current/projected scale (<1,000 users)

5. CHEAP POSTGRESQL OPTIONS (2025):
- Neon: Free tier (0.25 CU 24/7, 0.5GB), $19/mo Launch tier, serverless auto-scale
- Supabase: Free tier (Nano instance, 500MB), $25/mo Pro tier (fixed-size instances from $10/mo add-ons)
- Railway: ~$15/mo for 3 performant DBs (Hobby Tier $5 + compute)
- Cloud SQL: Shared-core (db-f1-micro) ~$10-20/mo, BUT default configs can cost $500+
- RECOMMENDATION: Neon or Supabase $19-25/mo range for production <1,000 users

6. KEY CUSTODY DATABASE PATTERNS:
- Fireblocks: MPC-based, key shares in Intel SGX enclaves + end-user devices
- BitGo: Multi-sig architecture, hardware-isolated keys, cold storage, SOC 2 Type 2
- Pattern: Application-level encryption with HSM/KMS + segregated vault structures
- NO EVIDENCE: That they use database-level encryption (focus is on key material isolation)

7. MIGRATION EFFORT (SQLite → PostgreSQL):
- sqlx supports both, but syntax differences: ? → $1, INTEGER → SERIAL, AUTOINCREMENT → SERIAL
- Estimated changes: ~80 queries across 13 files (found with grep)
- Migration tooling: sqlx-cli migrations work for both, sqlx_migrator for Rust-based migrations
- Feature flag approach: Possible with sqlx runtime detection, but adds code complexity
- BEST TIME TO MIGRATE: During active development (NOW) OR when hitting write bottleneck (LATER)

8. DECISION TRIGGERS - WHEN TO MIGRATE:
STAY ON SQLITE IF:
- <1,000 users, <50 tenants
- Write load <500 writes/sec sustained
- Single-region deployment acceptable
- Development velocity prioritized

MIGRATE TO POSTGRESQL IF:
- >1,000 users OR >50 tenants
- SQLITE_BUSY errors occurring in production
- Need multi-region read replicas
- Planning to use RLS for tenant isolation defense-in-depth
- Team size growing (more developers = more risk of tenant_id bugs)

MIDDLE GROUND - SQLite with Database-Per-Tenant:
- Each tenant gets separate .db file
- Litestream replicates all tenant DBs to GCS
- Connection pooling: One pool per tenant DB (lazy init on first tenant request)
- Scales to ~50-100 tenants before management complexity outweighs benefits
- ADVANTAGE: Complete tenant isolation + SQLite simplicity
- CAVEAT: Litestream not tested at scale with hundreds of DBs (creator's warning)

RECOMMENDATION FOR KEYCAST:
1. STAY ON SQLITE for now (current scale doesn't justify migration)
2. KEEP multi-tenancy via tenant_id column (simplest approach)
3. ADD automated tests that verify all queries include tenant_id filtering
4. MONITOR write contention: Log SQLITE_BUSY errors, alert if >1% of queries
5. MIGRATION TRIGGER: When SQLITE_BUSY errors >1% OR user count >1,000
6. IF MIGRATING: Neon $19/mo or Supabase $25/mo, implement PostgreSQL RLS for defense-in-depth
7. APPLICATION ENCRYPTION SUFFICIENT: No need for database-level encryption with current architecture
